"""
    download(
        e5ds :: Union{ERA5Hourly,ERA5Monthly},
        evar :: SingleVariable,
        ereg :: ERA5Region;
        ispy :: Bool = false,
        overwrite :: Bool = false
    ) -> nothing

Downloads ERA5 data from the CDS datastore for a specified Single-Level variable and geographic region.  You can specify to download via python scripts generated by selecting `ispy` to `true`, or to instead use Julia directly.

You must have installed the CDSAPI on your machine and have accepted the terms and conditions on the CDS website in order for this to work.

Arguments
=========

- `e5ds` : The ERA5Dataset specified (Hourly or Monthly)
    - `e5ds.start` defines the start date
    - `e5ds.stop` defines the end date
    - `e5ds.path` defines the path to which all reanalysis data is saved
- `evar` : Specifies the Single-Level variable to be downloaded
- `ereg` : Specifies the `GeoRegion` and the resolution of the data to be downloaded
- `ipsy` : Specifies whether to generate a python script that can be used to download the data instead of Julia
- `overwrite` : `false` by default. If set to true, existing data will be overwritten.
"""
function accessdkrz(
    e5ds :: ERA5Hourly,
    evar :: ERA5Variable,
    date :: Date;
    domodellevel :: Bool = false,
    doforecast   :: Bool = false,
    doothertype  :: Bool = true
)

    checkdkrzvariable(evar)
    level = checkdkrzlevel(evar,domodellevel)
    tres  = checkdkrztres(e5ds,evar)
    type,typeID = checkanfc(evar,doforecast)

    path = "/pool/data/ERA5/E5/$(level)/$(type)/$(tres)/$(@sprintf("%03d",evar.dkrz))"
    if !evar.invariant
        fID = "E5$(level)$(typeID)_$(tres)_$(date)_$(@sprintf("%03d",evar.dkrz)).grb"
    else
        fID = "E5$(level)$(typeID)_$(tres)_2001-01-01_$(@sprintf("%03d",evar.dkrz)).grb"
    end

    fgrb = joinpath(path,fID)

    if !isfile(fgrb)
        if doothertype
            if !doforecast
                path = "/pool/data/ERA5/E5/$(level)/fc/$(tres)/$(@sprintf("%03d",evar.dkrz))"
                fID = "E5$(level)12_$(tres)_$(date)_$(@sprintf("%03d",evar.dkrz)).grb"
            elseif doforecast
                path = "/pool/data/ERA5/E5/$(level)/an/$(tres)/$(@sprintf("%03d",evar.dkrz))"
                fID = "E5$(level)00_$(tres)_$(date)_$(@sprintf("%03d",evar.dkrz)).grb"
            end
        else
            error("$(modulelog()) - The file $(fgrb) does not exist, likely you need to set doothertype to `true` because DKRZ has it as a forecast variable instead of an analysis variable or vice versa")
        end
        fgrb = joinpath(path,fID)
    end

    return GRIBDataset(fgrb)

end

function accessdkrz(
    e5ds :: ERA5Monthly,
    evar :: ERA5Variable,
    date :: Date;
    domodellevel :: Bool = false,
    doforecast   :: Bool = false,
    doothertype  :: Bool = true
)

    checkdkrzvariable(evar)
    level = checkdkrzlevel(evar,domodellevel)
    tres  = checkdkrztres(e5ds,evar)
    type,typeID = checkanfc(evar,doforecast)

    path = "/pool/data/ERA5/E5/$(level)/$(type)/$(tres)/$(@sprintf("%03d",evar.dkrz))"
    if !evar.invariant
        fID = "E5$(level)$(typeID)_$(tres)_$(year(date))_$(@sprintf("%03d",evar.dkrz)).grb"
    else
        fID = "E5$(level)$(typeID)_$(tres)_2001_$(@sprintf("%03d",evar.dkrz)).grb"
    end

    fgrb = joinpath(path,fID)

    if !isfile(fgrb)
        if doothertype
            if !doforecast
                path = "/pool/data/ERA5/E5/$(level)/fc/$(tres)/$(@sprintf("%03d",evar.dkrz))"
                fID = "E5$(level)12_$(tres)_$(year(date))_$(@sprintf("%03d",evar.dkrz)).grb"
            elseif doforecast
                path = "/pool/data/ERA5/E5/$(level)/an/$(tres)/$(@sprintf("%03d",evar.dkrz))"
                fID = "E5$(level)00_$(tres)_$(year(date))_$(@sprintf("%03d",evar.dkrz)).grb"
            end
        else
            error("$(modulelog()) - The file $(fgrb) does not exist, likely you need to set doothertype to `true` because DKRZ has it as a forecast variable instead of an analysis variable or vice versa")
        end
        fgrb = joinpath(path,fID)
    end

    return GRIBDataset(fgrb)

end

function dkrz(
    e5ds :: ERA5CDStore,
    evar :: SingleVariable,
    egeo :: ERA5Region;
    domodellevel :: Bool = false,
    doforecast   :: Bool = false,
    doothertype  :: Bool = true,
    overwrite    :: Bool = false
)

    dtvec = e5ds.start : Month(1) : e5ds.stop; ndt = length(dtvec)
    geo = egeo.geo
    elon,elat = ERA5Reanalysis.nativelonlat()
    ggrd = RegionGrid(geo,Point2.(elon,elat)); npnts = length(ggrd.ipoint)
    tmat = zeros(npnts,24)
    vmat = zeros(Float32,npnts,24*ndt)

    if egeo.isglb
        ipnts = minimum(ggrd.ipoint) : maximum(ggrd.ipoint)
    else
        ipnts = ggrd.ipoint
    end

    @info "$(now()) - S2DExploration - Extracting $(uppercase(e5ds.name)) $(evar.name) data in $(egeo.geo.name) (Native T639 Resolution) from $(e5ds.start) to $(e5ds.stop) from the DKRZ Servers"

    for idt in dtvec

        yr  = year(idt)
        mo  = month(idt)
        ndy = daysinmonth(idt)
        ndt = ndy * 24

        @info "$(now()) - S2DExploration - Extracting $(evar.name) data for $yr-$(@sprintf("%02d",mo)) ..."

        if !isfile(e5dfnc(e5ds,evar,egeo,idt)) || overwrite
        
            for iday in 1 : ndy

                ibeg = (iday-1) * 24 + 1
                iend = iday * 24
                gds = accessdkrz(
                    e5ds,evar,Date(yr,mo,iday),
                    domodellevel=domodellevel,doforecast=doforecast,
                    doothertype=doothertype
                )
                tmat .= nomissing(gds[evar.ID][ipnts,:],NaN)
                vmat[:,ibeg:iend] .= Float32.(tmat)
                close(gds)

            end

            save(view(vmat,:,1:ndt),idt,e5ds,evar,egeo,ggrd)

        end

    end

end

checkdkrzvariable(evar::ERA5Variable) = ismissing(evar.dkrz) ? error("$(modulelog()) - This ERA5Variable is unfortunately not provided by the DKRZ servers.") : nothing

checkdkrzlevel(::SingleVariable,:: Bool) = "sf"
checkdkrzlevel(::PressureVariable,domodellevel:: Bool) = domodellevel ? "ml" : "pl"

checkdkrztres(::ERA5Hourly,::PressureVariable)  = "1H"
checkdkrztres(::ERA5Daily,::PressureVariable)   = "1D"
checkdkrztres(::ERA5Monthly,::PressureVariable) = "1M"

checkdkrztres(::ERA5Hourly,evar::SingleVariable)  = evar.invariant ? "IV" : "1H"
checkdkrztres(::ERA5Daily,evar::SingleVariable)   = evar.invariant ? "IV" : "1D"
checkdkrztres(::ERA5Monthly,evar::SingleVariable) = evar.invariant ? "IV" : "1M"

function checkanfc(evar::SingleVariable,doforecast::Bool)

    if evar.analysis && evar.forecast
        if doforecast; return "fc", "12" else; return "an", "00" end
    elseif evar.analysis
        return "an", "00"
    elseif evar.forecast
        return "fc", "12"
    else
        error("$(modulelog()) - This ERA5Variable is neither an analysis or forecast variable, please contact natgeo-wong to see if he knows what's going on")
    end

end

function checkanfc(::PressureVariable,doforecast::Bool)

    if doforecast
        return "fc", "12"
    else
        return "an", "00"
    end

end

function nativelonlat()

    fname = joinpath(eradir,"dkrzlonlat.txt")
    data = readdlm(fname,',')[:,:]; nlon = Int.(data[:,1]); lat = data[:,2]
    npnt = sum(nlon); nrow = length(lat)
    elon = zeros(npnt)
    elat = zeros(npnt)

    ibeg = Int(0)
    iend = Int(0)
    for irow = 1 : nrow
        ilon  = nlon[irow]
        ibeg  = iend + 1
        iend += ilon
        elon[ibeg:iend] = (0:(ilon-1)) * 360 / ilon
        elat[ibeg:iend] .= lat[irow]
    end

    return elon,elat

end

function closestnativelonlat(
    pnt :: Point2
)

    elon,elat = nativelonlat()
    ex = cosd.(elon) .* cosd.(elat)
    ey = sind.(elon) .* cosd.(elat)
    ez = sind.(elat)

    plon,plat = pnt[1],pnt[2]
    px = cosd.(plon) * cosd.(plat)
    py = sind.(plon) * cosd.(plat)
    pz = sind.(plat)

    return argmin(abs.((ex.-px).^2 .+ (ey.-py).^2 .+ (ez.-pz).^2))

end

function closestnativelonlat(
    pnts :: Vector{Point2{FT}}
) where FT <: Real

    elon,elat = nativelonlat()
    ex = cosd.(elon) .* cosd.(elat)
    ey = sind.(elon) .* cosd.(elat)
    ez = sind.(elat)

    npnts = length(pnts)
    iarg  = zeros(Int,npnts)
    for ii in 1 : npnts
        ipnt = pnts[ii]
        plon,plat = ipnt[1],ipnt[2]
        px = cosd.(plon) * cosd.(plat)
        py = sind.(plon) * cosd.(plat)
        pz = sind.(plat)
        iarg[ii] = argmin(abs.((ex.-px).^2 .+ (ey.-py).^2 .+ (ez.-pz).^2))
    end

    return iarg

end